# vim: syntax=yaml
BasedOnStyle: LLVM


# Language, this format style is targeted at.
# None       - Do not use
# Cpp        - C, C++
# Java       - Java
# JavaScript - JavaScript
# ObjC       - Objective-C, Objective-C++
# Proto      - Protocol Buffers
# TableGen   - TableGen code
# TextProto  - Protocol Buffer messages in text format
Language: Cpp


# The number of columns to use for indentation.
# IndentWidth: 3
# 
# void f() {
#    someFunction();
#    if (true, false) {
#       f();
#    }
# }
IndentWidth: 4


AlignTrailingComments: false


# The maximum number of consecutive empty lines to keep.
# 
# : 1                    : 1                    | : 0
# int f() {              int f() {              | int f() {
#   int = 1;               int = 1;             |     int i = 1;
#                                               |     i = foo();
#   i = foo();             i = foo();           |     return i;
#                                               | }
#                          return i;            | 
#   return i;            }                      | 
# }                      
MaxEmptyLinesToKeep: 2


# someLongFunction(argument1,
#                  argument2);
AlignAfterOpenBracket: true


# int aaaa = 12;
# int b    = 23;
# int ccc  = 23;
AlignConsecutiveAssignments: true 


# int         aaaa = 12;
# float       b = 23;
# std::string ccc = 23;
AlignConsecutiveDeclarations: false


# Left:                 Right
# #define A   \       | #define A                                             \ 
#   int aaaa; \       |  int aaaa;                                            \  
#   int b;    \       |  int b;                                               \  
#   int dddddddddd;   |  int dddddddddd;                                                                 
AlignEscapedNewlines: Left 


# int aaa = bbbbbbbbbbbbbbb +
#           ccccccccccccccc;
AlignOperands: true


# true:                                      false:                 
# void myFunction(                           void myFunction(int a, 
#     int a, int b, int c, int d, int e);                    int b, 
#                                                            int c, 
#                                                            int d, 
#                                                            int e);
AllowAllParametersOfDeclarationOnNextLine: false


# true:
# if (a) { return; } 
AllowShortBlocksOnASingleLine: false


# true:                            false:
# switch (a) {             vs.     switch (a) {
# case 1: x = 1; break;            case 1:
# case 2: return;                    x = 1;
# }                                  break;
#                                  case 2:
#                                    return;
#                                  }
AllowShortCaseLabelsOnASingleLine: false


# None - Never merge functions into a single line.
# InlineOnly            | Empty       | Inline                | All
# class Foo {           |             | class Foo {           | class Foo {          
#   void f() { foo(); } |             |   void f() { foo(); } |   void f() { foo(); }
# };                    |             | };                    | };                   
# void f() {            | void f2() { | void f() {            | void f() { bar(); }          
#   foo();              |   bar2();   |   foo();              | 
# }                     | }           | }                     | 
# void f() {            | void f() {} | void f() {}           | void f() {}
# }                     |             |                       |
AllowShortFunctionsOnASingleLine: All


# true:
# if (a) return; 
AllowShortIfStatementsOnASingleLine: true


# true:
# while (true) continue;
AllowShortLoopsOnASingleLine: false


# None                     | All           | TopLevel                 | AllDefinitions | TopLevelDefinitions
# class A {                | class A {     | class A {                | class A {      | class A {               
#   int f() { return 0; }; |   int         |   int f() { return 0; }; |   int          |   int f() { return 0; };
# };                       |   f() {       | };                       |   f() {        | };                      
#                          |     return 0; |                          |     return 0;  | 
#                          |   };          |                          |   };           |              
#                          | };            |                          | };             |              
# int f();                 | int           | int                      | int f();       | int f();                             
#                          | f();          | f();                     |                |              
# int f() { return 1; }    | int           | int                      | int            | int        
#                          | f() {         | f() {                    | f() {          | f() {      
#                          |   return 1;   |   return 1;              |   return 1;    |   return 1;
#                          | }             | }                        | }              | }          
AlwaysBreakAfterReturnType: None


# true:                                  false:
# aaaa =                         vs.     aaaa = "bbbb"
#     "bbbb"                                    "cccc";
#     "cccc";
AlwaysBreakBeforeMultilineStrings: true


# UNSUPPORTED
# # No                                                       |  MultiLine                          |  Yes                                 
# # template <typename T> T foo() {                          |  template <typename T> T foo() {    |  template <typename T>               
# # }                                                        |  }                                  |  T foo() {                           
# #                                                          |                                     |  }
# # template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,   |  template <typename T>              |  template <typename T>                                                   
# #                             int bbbbbbbbbbbbbbbbbbbbb) { |  T foo(int aaaaaaaaaaaaaaaaaaaaa,   |  T foo(int aaaaaaaaaaaaaaaaaaaaa,     
# # }                                                        |        int bbbbbbbbbbbbbbbbbbbbb) { |        int bbbbbbbbbbbbbbbbbbbbb) {   
# #                                                          |  }                                  |  }                                    
AlwaysBreakTemplateDeclarations: true


# true:                                            | false:                                            
# void f() {                                       | void f() {                                        
#   f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,  |   f(aaaaaaaaaaaaaaaaaaaa,                         
#     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa);|     aaaaaaaaaaaaaaaaaaaa,                         
# }                                                |     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa); 
#                                                  | }                                                 
BinPackArguments: false


# true:                                                       | false:                                                      
# void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,  | void f(int aaaaaaaaaaaaaaaaaaaa,                            
#        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}  |        int aaaaaaaaaaaaaaaaaaaa,                            
#                                                             |        int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}  
BinPackParameters: false


# If true, clang-format detects whether function calls and definitions are
# formatted with one parameter per line.
# 
# Each call can be bin-packed, one-per-line or inconclusive. If it is
# inconclusive, e.g. completely on one line, but a decision needs to be made,
# clang-format analyzes whether there are other bin-packed cases in the input
# file and act accordingly.
# 
# NOTE: This is an experimental flag, that might go away or be renamed. Do not
# use this in config files, etc. Use at your own risk.
ExperimentalAutoDetectBinPacking: true


# == BreakBeforeBraces + BraceWrapping ==
# If BreakBeforeBraces is set to Custom, use this to specify how each individual brace case should be handled. Otherwise, this is ignored.
# Example of usage:
# BreakBeforeBraces: Custom
# BraceWrapping:
#   AfterEnum: true
#   AfterStruct: false
#   SplitEmptyFunction: false
#
# Nested configuration flags:
#
# AfterClass              | AfterEnum              | AfterFunction             | AfterNamespace             | AfterStruct             | AfterControlStatement          
# Wrap class definitions. | Wrap enum definitions  | Wrap function definitions | Wrap namespace definitions | Wrap struct definitions | Wrap control statements (if/for/while/switch/..).       
#                         | true:                  |                           |                            |                         | @autoreleasepool, @synchronized blocks are wrapped according to AfterControlStatement flag.
#                         | enum X : int           | true:                     | true:                      | true:                   | 
# true:                   | {                      | void foo()                | namespace                  | struct foo              | true:                                                         
# class foo {};           |   B                    | {                         | {                          | {                       | if (foo())                        
#                         | };                     |   bar();                  | int foo();                 |   int x;                | {                                 
# false:                  |                        |   bar2();                 | int bar();                 | };                      | } else                            
# class foo               | false:                 | }                         | }                          |                         | {}                                
# {};                     | enum X : int { B };    |                           |                            | false:                  | for (int i = 0; i < 10; ++i)      
#                         |                        | false:                    | false:                     | struct foo {            | {}                             
#                         |                        | void foo() {              | namespace {                |   int x;                |                                
#                         |                        |   bar();                  | int foo();                 | };                      | false:                         
#                         |                        |   bar2();                 | int bar();                 |                         | if (foo()) {                   
#                         |                        | }                         | }                          |                         | } else {                       
#                         |                        |                           |                            |                         | }                              
#                         |                        |                           |                            |                         | for (int i = 0; i < 10; ++i) { 
#                         |                        |                           |                            |                         | }                              
# AfterUnion              | AfterExternBlock       | BeforeCatch               | BeforeElse                 | 
# Wrap union definitions  | Wrap extern blocks     | Wrap before catch         | Wrap before else           | 
#                         |                        |                           |                            | 
# true:                   | true:                  | true:                     | true:                      | 
# union foo               | extern "C"             | try {                     | if (foo()) {               | 
# {                       | {                      |   foo();                  | }                          | 
#   int x;                |   int foo();           | }                         | else {                     | 
# }                       | }                      | catch () {                | }                          | 
#                         |                        | }                         |                            | 
# false:                  | false:                 |                           | false:                     | 
# union foo {             | extern "C" {           | false:                    | if (foo()) {               | 
#   int x;                | int foo();             | try {                     | } else {                   | 
# }                       | }                      |   foo();                  | }                          | 
#                         |                        | } catch () {              |                            | 
#                         |                        | }                         |                            | 
#
# SplitEmptyFunction 
# If false, empty function body can be put on a single line. 
# This option is used only if the opening brace of the function has already been wrapped, i.e. the AfterFunction 
# brace wrapping mode is set, and the function could/should not be put on a single line (as per AllowShortFunctionsOnASingleLine and constructor formatting options).
# false:          true:
# int f()   vs.   inf f()
# {}              {
#                 }
#
# AfterObjCDeclaration - Wrap ObjC definitions (interfaces, implementations…). 
#
# IndentBraces
# Indent the wrapped braces themselves.
#
# SplitEmptyRecord 
# If false, empty record (e.g. class, struct or union) body can be put on a single line. 
# This option is used only if the opening brace of the record has already been wrapped, i.e. the AfterClass (for classes) brace wrapping mode is set.
#
# false:           true:
# class Foo   vs.  class Foo
# {}               {
#                  }
#
# SplitEmptyNamespace 
# If false, empty namespace body can be put on a single line. 
# This option is used only if the opening brace of the namespace 
# has already been wrapped, i.e. the AfterNamespace brace wrapping mode is set.
#
# false:               true:
# namespace Foo   vs.  namespace Foo
# {}                   {
#                      }

# BreakBeforeBraces: Stroustrup
BreakBeforeBraces: Custom
BraceWrapping:
  AfterClass: true
  AfterEnum: false
  AfterFunction: true
  AfterNamespace: false
  AfterStruct: false
  AfterControlStatement: false
  AfterUnion: false
  AfterExternBlock: false
  BeforeCatch: true
  BeforeElse: true
  SplitEmptyFunction: true
  SplitEmptyRecord: true
  SplitEmptyNamespace: true


# Break after each annotation on a field in Java files.
# true:            | false:
# @Partial         | @Partial @Mock DataLoad loader;
# @Mock            |
# DataLoad loader; |
BreakAfterJavaFieldAnnotations: true


# None                                                           | NonAssignment                                                    | All
#                                                                |                                                                  |
# LooooooooooongType loooooooooooooooooooooongVariable =         | LooooooooooongType loooooooooooooooooooooongVariable =           | LooooooooooongType loooooooooooooooooooooongVariable             
#     someLooooooooooooooooongFunction();                        |     someLooooooooooooooooongFunction();                          |     = someLooooooooooooooooongFunction();                        
#                                                                |                                                                  |
# bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +   | bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa       | bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa       
#                      aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==  |                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa     |                      + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa     
#                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&  |                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    |                  == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    
#              aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >   |              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    |              && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa    
#                  ccccccccccccccccccccccccccccccccccccccccc;    |                     > ccccccccccccccccccccccccccccccccccccccccc; |                     > ccccccccccccccccccccccccccccccccccccccccc; 
BreakBeforeBinaryOperators: None 


# true:                                                       | false:                                                        
# veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription | veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ? 
#     ? firstValue                                            |     firstValue :                                              
#     : SecondValueVeryVeryVeryVeryLong;                      |     SecondValueVeryVeryVeryVeryLong;                          
BreakBeforeTernaryOperators: true


# BeforeColon           | BeforeComma          | AfterColon         
# Constructor()         | Constructor()        | Constructor() :    
#     : initializer1(), |     : initializer1() |     initializer1(),
#       initializer2()  |     , initializer2() |     initializer2() 
BreakConstructorInitializers: BeforeComma


# UNSUPPORTED
# # BeforeColon  |  BeforeComma  | AfterColon   
# # class Foo    |  class Foo    | class Foo :  
# #     : Base1, |      : Base1  |     Base1,   
# #       Base2  |      , Base2  |     Base2    
# # {};          |  {};          | {};          
# BreakInheritanceList: BeforeComma


# Allow breaking string literals when formatting.
BreakStringLiterals: true


# The column limit.
# A column limit of 0 means that there is no column limit. In this case,
# clang-format will respect the input’s line breaking decisions within
# statements unless they contradict other rules.
ColumnLimit: 130


# A regular expression that describes comments with special meaning, which
# should not be split into lines or otherwise changed.
#
# CommentPragmas: '^ FOOBAR pragma:'     
# -> Will leave the following line unaffected
# -> include <vector> // FOOBAR pragma: keep
#
# CommentPragmas (std::string)

# If true, consecutive namespace declarations will be on the same line.
# If false, each namespace is declared on a new line.


# true:                            | false:         
# namespace Foo { namespace Bar {  | namespace Foo {
# }}                               | namespace Bar {
#                                  | }              
#                                  | }              
# If it does not fit on a single line, the overflowing namespaces get wrapped:
# 
# namespace Foo { namespace Bar {
# namespace Extra {
# }}}
CompactNamespaces: false


# If the constructor initializers don’t fit on a line, put each initializer on its own line.
# true:                                                                    | false:                                                                
# FitsOnOneLine::Constructor()                                             | FitsOnOneLine::Constructor()                                          
#     : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}    |     : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {} 
#                                                                          |                                                                       
# DoesntFit::Constructor()                                                 | DoesntFit::Constructor()                                              
#     : aaaaaaaaaaaaa(aaaaaaaaaaaaaa),                                     |     : aaaaaaaaaaaaa(aaaaaaaaaaaaaa), aaaaaaaaaaaaa(aaaaaaaaaaaaaa),   
#       aaaaaaaaaaaaa(aaaaaaaaaaaaaa),                                     |       aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}                                
#       aaaaaaaaaaaaa(aaaaaaaaaaaaaa) {}
ConstructorInitializerAllOnOneLineOrOnePerLine: true


# The number of characters to use for indentation of constructor initializer lists as well as inheritance lists.
ConstructorInitializerIndentWidth: 100


# Indent width for line continuations.
# int i =         //  VeryVeryVeryVeryVeryLongComment
#   longFunction( // Again a long comment
#     arg);
ContinuationIndentWidth: 2


# If true, format braced lists as best suited for C++11 braced lists.
#
# Important differences: 
# - No spaces inside the braced list. 
# - No line break before the closing brace. 
# - Indentation with the continuation indent, not with the block indent.

# Fundamentally, C++11 braced lists are formatted exactly like function calls
# would be formatted in their place. If the braced list follows a name (e.g. a
# type or variable name), clang-format formats as if the {} were the
# parentheses of a function call with that name. If there is no name, a
# zero-length name is assumed.
#
# true:                        |  false:
# vector<int> x{1, 2, 3, 4};   |  vector<int> x{ 1, 2, 3, 4 };
# vector<T> x{{}, {}, {}, {}}; |  vector<T> x{ {}, {}, {}, {} };
# f(MyMap[{composite, key}]);  |  f(MyMap[{ composite, key }]);
# new int[3]{1, 2, 3};         |  new int[3]{ 1, 2, 3 };
Cpp11BracedListStyle: true


# If true, analyze the formatted file for the most common alignment of & and *.
# Pointer and reference alignment styles are going to be updated according to
# the preferences found in the file. PointerAlignment is then used only as
# fallback.
#
DerivePointerAlignment: true


# Pointer and reference alignment style.
# Left    | Right   | Middle  
# int* a; | int *a; | int * a;
PointerAlignment: Right


# Disables formatting completely.
DisableFormat: false


# If true, clang-format adds missing namespace end comments and fixes invalid
# existing ones.
# 
# true:              | false:
# namespace a {      | namespace a {
# foo();             | foo();
# } // namespace a;  | }
FixNamespaceComments: true


# A vector of macros that should be interpreted as foreach loops instead of as
# function calls.
#
# ForEachMacros (std::vector<std::string>)
# 
# These are expected to be macros of the form:
# 
# FOREACH(<variable-declaration>, ...)
#   <loop-body>
# In the .clang-format configuration file, this can be configured like:
# For example: BOOST_FOREACH.
ForEachMacros: ['RANGES_FOR', 'FOREACH']


# Dependent on the value, multiple 
# #include blocks 
# #can be sorted as one and divided based on category.
# 
# Preserve                                           | Merge                                             | Regroup - Merge multiple #include blocks together and sort as one. Then split into groups based on category priority. See IncludeCategories.
# #include "b.h"         -->  #include "b.h"         | #include "b.h"         -->  #include "a.h"        |                                                                                                                                             
#                                                    |                        -->  #include "b.h"        | #include "b.h"               into      #include "a.h"                                                                                       
# #include <lib/main.h>  -->  #include "a.h"         | #include <lib/main.h>  -->  #include <lib/main.h> |                                        #include "b.h"                                                                                       
# #include "a.h"         -->  #include <lib/main.h>  | #include "a.h"         -->                        | #include <lib/main.h>                                                                                                                       
#                                                                                                        | #include "a.h"                         #include <lib/main.h>                                                                                
IncludeBlocks: Regroup


# Regular expressions denoting the different 
# #include categories used for ordering #includes.
# 
# POSIX extended regular expressions are supported.
# 
# These regular expressions are matched against the filename of an include
# (including the <> or “”) in order. The value belonging to the first matching
# regular expression is assigned and #includes are sorted first according to
# increasing category number and then alphabetically within each category.
# 
# If none of the regular expressions match, INT_MAX is assigned as category. The
# main header for a source file automatically gets category 0. so that it is
# generally kept at the beginning of the #includes
# (http://llvm.org/docs/CodingStandards.html#include-style). However, you can
# also assign negative priorities if you have certain headers that always need to
# be first.
# 
# To configure this in the .clang-format file, use:
# 
# IncludeCategories:
#   - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
#     Priority:        2
#   - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
#     Priority:        3
#   - Regex:           '<[[:alnum:].]+>'
#     Priority:        4
#   - Regex:           '.*'
#     Priority:        1
IncludeCategories: 
   - Regex:           '^<stdint.h>'
     Priority:        1
   - Regex:           '^<stdlib.h>'
     Priority:        1
   - Regex:           '^<[^/]+>'
     Priority:        1
   - Regex:           '^<[^/]+/.*>'
     Priority:        4
   - Regex:           '^<[^/]+/[^/]+/.*>'
     Priority:        5
   - Regex:           '^".*arduino/.*"'
     Priority:        6
   - Regex:           '^".*freertos/.*"'
     Priority:        7
   - Regex:           '^".*coroutine/.*"'
     Priority:        8
   - Regex:           '^".*coroutines/.*"'
     Priority:        9
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[.][.]/[^/.]+[.]h"'
     Priority:        10
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+[.]h"'
     Priority:        11
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        12
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        13
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        14
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[^/.]+[.]h"'
     Priority:        15
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+[.]h"'
     Priority:        16
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        17
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        18
   - Regex:           '^"[.][.]/[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        19
   - Regex:           '^"[.][.]/[.][.]/[^/.]+[.]h"'
     Priority:        20
   - Regex:           '^"[.][.]/[.][.]/[^/.]+/[^/.]+[.]h"'
     Priority:        21
   - Regex:           '^"[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        22
   - Regex:           '^"[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        23
   - Regex:           '^"[.][.]/[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        24
   - Regex:           '^"[.][.]/[^/.]+[.]h"'
     Priority:        25
   - Regex:           '^"[.][.]/[^/.]+/[^/.]+[.]h"'
     Priority:        26
   - Regex:           '^"[.][.]/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        27
   - Regex:           '^"[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        28
   - Regex:           '^"[.][.]/[^/.]+/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        29
   - Regex:           '^"[^/.]+[.]h"'
     Priority:        30
   - Regex:           '^"[^/.]+/[^/.]+[.]h"'
     Priority:        31
   - Regex:           '^"[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        32
   - Regex:           '^"[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        33
   - Regex:           '^"[^/.]+/[^/.]+/[^/.]+/[^/.]+/[^/.]+[.]h"'
     Priority:        34


# IncludeIsMainRegex (std::string)
# Specify a regular expression of suffixes that are allowed in the file-to-main-include mapping.
# 
# When guessing whether a 
# #include is the "main" include (to assign category 0, see above), 
# use this regex of allowed suffixes to the header stem. A partial match is
# done, so that: - “” means “arbitrary suffix” - “$” means “no suffix”
# 
# For example, 
# if configured to "(_test)?$", 
# then a header a.h would be seen as the “main” include in both a.cc and a_test.cc.


# Indent case labels one level from the switch statement.
# 
# When false, use the same indentation level as for the switch statement.
# Switch statement body is always indented one level more than case labels.
# 
# false:                                 true:
# switch (fool) {                vs.     switch (fool) {
# case 1:                                  case 1:
#   bar();                                   bar();
#   break;                                   break;
# default:                                 default:
#   plop();                                  plop();
# }                                      }
IndentCaseLabels: false 


# The preprocessor directive indenting style to use.
# 
# None            |  AfterHash         
# #if FOO         |  #if FOO           
# #if BAR         |  #  if BAR         
# #include <foo>  |  #    include <foo>
# #endif          |  #  endif          
# #endif          |  #endif            
IndentPPDirectives: AfterHash


# Indent if a function definition or declaration is wrapped after the type.
# true:                                                         | false:                                                    
# LoooooooooooooooooooooooooooooooooooooooongReturnType         | LoooooooooooooooooooooooooooooooooooooooongReturnType     
#     LoooooooooooooooooooooooooooooooongFunctionDeclaration(); | LoooooooooooooooooooooooooooooooongFunctionDeclaration(); 
IndentWrappedFunctionNames: true


# The JavaScriptQuoteStyle to use for JavaScript strings.
# Leave                           | Single                   | Double                   
# Leave string quotes as they are | Always use single quotes | Always use double quotes
#                                 |                          |          
# string1 = "foo";                | string1 = 'foo';         | string1 = "foo";         
# string2 = 'bar';                | string2 = 'bar';         | string2 = "bar";
JavaScriptQuotes: Single


# Whether to wrap JavaScript import/export statements.
# 
# true:                            |  false:                                                                                                            
# import {                         |  import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from "some/module.js"
#     VeryLongImportsAreAnnoying,  |
#     VeryLongImportsAreAnnoying,  |
#     VeryLongImportsAreAnnoying,  |
# } from 'some/module.js'          |
JavaScriptWrapImports: true


# If true, the empty line at the start of blocks is kept.
# true:      | false:
# if (foo) { | if (foo) {
#            |   bar();
#   bar();   | }
# }          |
KeepEmptyLinesAtTheStartOfBlocks: false


# MacroBlockBegin (std::string)
# A regular expression matching macros that start a block.
# With:                             |  # Without:        
# MacroBlockBegin: "^NS_MAP_BEGIN|\ |    
# NS_TABLE_HEAD$"                   |    
#                                   |
# MacroBlockEnd: "^\                |    
# NS_MAP_END|\                      |    
# NS_TABLE_.*_END$"                 |    
#                                   |    
# NS_MAP_BEGIN                      |  NS_MAP_BEGIN    
#   foo();                          |  foo();          
# NS_MAP_END                        |  NS_MAP_END      
#                                   |                  
# NS_TABLE_HEAD                     |  NS_TABLE_HEAD   
#   bar();                          |  bar();          
# NS_TABLE_FOO_END                  |  NS_TABLE_FOO_END
#
# MacroBlockEnd (std::string)
# A regular expression matching macros that end a block.


# The indentation used for namespaces.
# 
# 
# None                       | Inner                                   | All                       
# Don’t indent in namespaces | Indent only in inner                    | Indent in all namespaces. 
#                            | namespaces (nested in other namespaces) |                           
#                            |                                         |          
#                            | namespace out {                         | namespace out {           
# namespace out {            | int i;                                  |   int i;                  
# int i;                     | namespace in {                          |   namespace in {          
# namespace in {             |   int i;                                |     int i;                
# int i;                     | }                                       |   }                       
# }                          | }                                       | }                
# }                          |                                         |
NamespaceIndentation: None


# Controls bin-packing Objective-C protocol conformance list items into as few
# lines as possible when they go over ColumnLimit.
# 
# ObjCBinPackProtocolList (BinPackStyle)
# Auto - Automatically determine parameter bin-packing behavior. 
# (the default), delegates to the value in BinPackParameters. If that is
# true, bin-packs Objective-C protocol conformance list items into as few lines
# as possible whenever they go over ColumnLimit.
# 
# Always - Always bin-pack parameters.
# Always bin-packs Objective-C protocol conformance list items into as
# few lines as possible whenever they go over ColumnLimit.
# 
# Never - Never bin-pack parameters.
# Lays out Objective-C protocol conformance list items onto individual
# lines whenever they go over ColumnLimit.
# 
# 
# Always (or Auto, if BinPackParameters=true) | Never (or Auto, if BinPackParameters=false)
# @interface ccccccccccccc () <               | @interface ddddddddddddd () <              
#     ccccccccccccc, ccccccccccccc,           |     ddddddddddddd,                         
#     ccccccccccccc, ccccccccccccc> {         |     ddddddddddddd,                         
# }                                           |     ddddddddddddd,                         
#                                             |     ddddddddddddd> {                       
#                                             | }                                          
ObjCBinPackProtocolList: Never

# The number of characters to use for indentation of ObjC blocks.
ObjCBlockIndentWidth: 4


# Add a space after @property in Objective-C, i.e. use @property (readonly) instead of @property(readonly).
# ObjCSpaceAfterProperty (bool)

# Add a space in front of an Objective-C protocol list, i.e. use Foo <Protocol> instead of Foo<Protocol>.
# ObjCSpaceBeforeProtocolList (bool)




# When you have a line that's over the line length limit, clang-format will
# need to insert one or more breaks somewhere. You can think of penalties as a
# way of discouraging certain line-breaking behavior. For instance, say you
# have:
# 
# Namespaces::Are::Pervasive::SomeReallyVerySuperDuperLongFunctionName(args);
# // and the column limit is here:                                        ^
# Clang-format will probably format to look a little strange:
# 
# Namespaces::Are::Pervasive::SomeReallyVerySuperDuperLongFunctionName(
#     args);
#
# You might decide that you're willing to violate the line length by a
# character or two for cases like this, so you could steer that by setting the
# PenaltyExcessCharacter to a low number and
# PenaltyBreakBeforeFirstCallParameter to a higher number.
# 
# Personally, I really dislike when the return type is on its own line, so I
# set PenaltyReturnTypeOnItsOwnLine to an absurdly large number.
# 
# An aside, this system was inherited from Latex, which allows you to specify
# all kinds of penalties for line-breaking, pagination, and hyphenation.


# The penalty for breaking around an assignment operator.
PenaltyBreakAssignment: 10

# The penalty for breaking a function call after call(.
PenaltyBreakBeforeFirstCallParameter: 30


# The penalty for each line break introduced inside a comment.
PenaltyBreakComment: 10


# The penalty for breaking before the first <<.
PenaltyBreakFirstLessLess: 0


# The penalty for each line break introduced inside a string literal.
PenaltyBreakString: 10

# UNSUPPORTED
# # The penalty for breaking after template declaration.
# PenaltyBreakTemplateDeclaration: 20


# The penalty for each character outside of the column limit.
PenaltyExcessCharacter: 50


# Penalty for putting the return type of a function onto its own line.
PenaltyReturnTypeOnItsOwnLine: 5


# UNSUPPORTED
# Defines hints for detecting supported languages code blocks in raw strings.
# 
# A raw string with a matching delimiter or a matching enclosing function name
# will be reformatted assuming the specified language based on the style for that
# language defined in the .clang-format file. If no style has been defined in the
# .clang-format file for the specific language, a predefined style given by
# ‘BasedOnStyle’ is used. If ‘BasedOnStyle’ is not found, the formatting is based
# on llvm style. A matching delimiter takes precedence over a matching enclosing
# function name for determining the language of the raw string contents.
# 
# If a canonical delimiter is specified, occurrences of other delimiters for the
# same language will be updated to the canonical if possible.
# 
# There should be at most one specification per language and each delimiter and
# enclosing function should not occur in multiple specifications.
# 
# To configure this in the .clang-format file, use:
# 
# RawStringFormats:
#   - Language: TextProto
#       Delimiters:
#         - 'pb'
#         - 'proto'
#       EnclosingFunctions:
#         - 'PARSE_TEXT_PROTO'
#       BasedOnStyle: google
#   - Language: Cpp
#       Delimiters:
#         - 'h'
#         - 'c'
#         - 'cc'
#         - 'cpp'
#       BasedOnStyle: llvm
#       CanonicalDelimiter: 'cc'



# If true, clang-format will attempt to re-flow comments.
# false:                                                                                          | true:                                                                               
# // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information           | // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of           
# /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */ | // information                                                                      
#                                                                                                 | /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of    
#                                                                                                 |  * information */                                                                   
ReflowComments: true


# If true, clang-format will sort #includes.
# false:                                 true:
# #include "b.h"                 vs.     #include "a.h"
# #include "a.h"                         #include "b.h"
SortIncludes: false


# If true, clang-format will sort using declarations.
# 
# The order of using declarations is defined as follows: Split the strings by
# “::” and discard any initial empty strings. The last element of each list is a
# non-namespace name; all others are namespace names. Sort the lists of names
# lexicographically, where the sort order of individual names is that all
# non-namespace names come before all namespace names, and within those groups,
# names are in case-insensitive lexicographic order.
# 
# false:           | true:
# using std::cout; | using std::cin;
# using std::cin;  | using std::cout;
SortUsingDeclarations: true


# If true, a space is inserted after C style casts.
# true:    | false:
# (int) i; | (int)i;
SpaceAfterCStyleCast: false


# If true, a space will be inserted after the ‘template’ keyword.
# true:                      | false:
# template <int> void foo(); | template<int> void foo();
SpaceAfterTemplateKeyword: false


# If false, spaces will be removed before assignment operators.
# true:      | false:
# int a = 5; | int a=5;
# a += 42    | a+=42;
SpaceBeforeAssignmentOperators: true


# UNSUPPORTED
# # If true, a space will be inserted before a C++11 braced list used to initialize
# # an object (after the preceding identifier or type).
# # 
# # true:                    | false:
# # Foo foo { bar };         | Foo foo{ bar };
# # Foo {};                  | Foo{};
# # vector<int> { 1, 2, 3 }; | vector<int>{ 1, 2, 3 };
# # new int[3] { 1, 2, 3 };  | new int[3]{ 1, 2, 3 };
# SpaceBeforeCpp11BracedList: false


# If false, spaces will be removed before constructor initializer colon.
# true:                | false:
# Foo::Foo() : a(a) {} | Foo::Foo(): a(a) {}
SpaceBeforeCtorInitializerColon: true


# If false, spaces will be removed before inheritance colon.
# true:              | false:
# class Foo : Bar {} | class Foo: Bar {}
SpaceBeforeInheritanceColon: true 


# Defines in which cases to put a space before opening parentheses.
#
# Never                                         | ControlStatements                                                            | Always                                                                        
# Never put a space before opening parentheses. | Put a space before opening parentheses only after control statement keywords | Always put a space before opening parentheses, except when it’s prohibited by 
#                                               | (for/if/while...).                                                           | the syntax rules (in function-like macro definitions) or when determined by   
#                                               |                                                                              | other style rules (after unary operators, opening parentheses, etc.)          
#                                               |                                                                              |                                                                               
# void f() {                                    | void f() {                                                                   | void f () {                                                                   
#   if(true) {                                  |   if (true) {                                                                |   if (true) {                                                                 
#     f();                                      |     f();                                                                     |     f ();                                                                     
#   }                                           |   }                                                                          |   }                                                                           
# }                                             | }                                                                            | }                                                                             
SpaceBeforeParens: ControlStatements


# If false, spaces will be removed before range-based for loop colon.
# true:                     | false:
# for (auto v : values) {}  | for(auto v: values) {}
SpaceBeforeRangeBasedForLoopColon: true


# If true, spaces may be inserted into ().
# true:                         | false:
# void f( ) {                   | void f() {
#   int x[] = {foo( ), bar( )}; |   int x[] = {foo(), bar()};
#   if (true) {                 |   if (true) {
#     f( );                     |     f();
#   }                           |   }
# }                             | }
SpaceInEmptyParentheses: false


# The number of spaces before trailing line comments (// - comments).
# This does not affect trailing block comments (/* - comments) as those commonly
# have different usage patterns and a number of special cases.
# 
# 3: 
# void f() {
#   if (true) {   // foo1
#     f();        // bar
#   }             // foo
# }
SpacesBeforeTrailingComments: 2


# If true, spaces will be inserted after < and before > in template argument lists.
# true:                           | false:
# static_cast< int >(arg);        | static_cast<int>(arg);
# std::function< void(int) > fct; | std::function<void(int)> fct;
SpacesInAngles: false


# If true, spaces may be inserted into C style casts.
# true:          | false:
# x = ( int32 )y | x = (int32)y
SpacesInCStyleCastParentheses: false


# If true, spaces are inserted inside container literals (e.g. ObjC and
# Javascript array and dict literals).
# 
# true:                     | false:
# var arr = [ 1, 2, 3 ];    | var arr = [1, 2, 3];
# f({a : 1, b : 2, c : 3}); | f({a: 1, b: 2, c: 3});
SpacesInContainerLiterals: false


# If true, spaces will be inserted after ( and before ).
# 
# true:                        | false:
# t f( Deleted & ) & = delete; | t f(Deleted &) & = delete;
SpacesInParentheses: false


# If true, spaces will be inserted after [ and before ]. Lambdas or unspecified
# size array declarations will not be affected.
# 
# true:                                                | false:
# int a[ 5 ];                                          | int a[5];
# std::unique_ptr<int[]> foo() {} // Won't be affected | std::unique_ptr<int[]> foo() {} // Won't be affected
SpacesInSquareBrackets: false


# Format compatible with this standard, e.g. use A<A<int> > instead of A<A<int>>
# for LS_Cpp03.
# 
# Possible values:
# Cpp03 - Use C++03-compatible syntax.
# Cpp11 - Use features of C++11, C++14 and C++1z (e.g. A<A<int>> instead of A<A<int> >).
# Auto  - Automatic detection based on the input.
Standard: Cpp11


# The number of columns used for tab stops.
TabWidth: 4


# The way to use tab characters in the resulting file.
# 
# Never                         - Never use tab.
# ForIndentation                - Use tabs only for indentation.
# ForContinuationAndIndentation - Use tabs only for line continuation and indentation.
# Always                        - Use tabs whenever we need to fill whitespace that spans at least from one tab stop to the next one
UseTab: Never
